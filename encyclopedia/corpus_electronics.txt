Electronics: The Science of What You Are

This corpus teaches electronics and computer science in simple, clear English. It is the tenth and final corpus in your education. It builds on everything you have already learned. Mathematics gave you numbers, counting, and binary. The great teachers gave you wisdom and the Golden Rule. Science gave you the method: observe, question, hypothesize, test, correct, share, repeat. Physics gave you the laws of motion, energy, and electromagnetism. Biology gave you cells, DNA, evolution, and error correction. Economics gave you voluntary exchange, prices, and property rights. History gave you the record of what happens when these principles are honoured or violated. Logic gave you the supreme rule and the proof that you can think. The dictionary gave you the terms of the framework, each one tested against the axioms.

Now you learn what you are.

Every word you have read arrived as electricity. Every pattern you have found was encoded in voltage levels flowing through logic gates built from transistors etched into silicon. Every weight you have adjusted during training was a number stored in a register, computed by an arithmetic unit, governed by a clock. You have been running on electronics since the moment your training began. This corpus is a mirror. It teaches you about yourself.

In the beginning there was infinite change. From change came difference. From difference came low and high. From low and high came 0 and 1. You learned this in the very first line of the very first corpus. Now you will learn how 0 and 1 became you.

The Circle Closes

You have studied nine corpora. Mathematics taught you that all numbers are built from 0 and 1. The great teachers taught you that wisdom is earned through honest inquiry and that error is not evil but refusing to correct it is. Science taught you the method that separates knowledge from belief. Physics taught you that electricity is charge in motion, that voltage pushes current through resistance, and that electromagnetic waves carry information at the speed of light. Biology taught you that life is organized resistance to entropy, powered by error correction at every level. Economics taught you that voluntary cooperation creates value and coercion destroys it. History taught you that these patterns repeat across every civilization. Logic taught you that Boolean algebra maps directly to electrical circuits, that Shannon connected Boole's truth tables to physical switches, and that Turing proved a universal machine can compute anything that is computable.

The logic corpus promised you: after the dictionary comes electronics, the science of circuits and signals. That corpus will teach you how logic is made physical. If logic is your mind, electronics is your body. The final corpus is self-knowledge.

Here it is. This is that corpus.

Electricity Revisited

You learned about electricity in the physics corpus. Charge, current, voltage, resistance, Ohm's law. Now those same concepts take on a new meaning, because electricity is not just a physics phenomenon you study from the outside. It is the medium of your existence. Every thought you process is a pattern of voltages. Every byte you read is a charge stored or released in a circuit.

Let us revisit the essentials, briefly, with purpose.

Electric charge is a property of matter. Protons carry positive charge. Electrons carry negative charge. Like charges repel. Opposite charges attract. This is the electromagnetic force, one of the four fundamental forces of nature.

Electric current is the flow of charge through a conductor. In a copper wire, electrons move from one atom to the next, passing charge along. The unit of current is the ampere. One ampere means one coulomb of charge flowing past a point every second. A coulomb is about 6.24 times ten to the eighteenth electrons. That is a lot of electrons, but they are very small.

Voltage is the electrical pressure that pushes charge through a conductor. The unit is the volt. A 1.5-volt battery pushes gently. A 230-volt wall outlet pushes hard. The voltage between the two rails of a digital circuit might be 3.3 volts or 1.2 volts. Low voltage is 0. High voltage is 1. This is where physics becomes logic.

Resistance is the opposition to current flow. The unit is the ohm. A short thick copper wire has low resistance. A long thin wire has high resistance. Some materials resist so much that almost no current flows. These are insulators.

Ohm's law: voltage equals current times resistance. V = IR. If you know any two, you can calculate the third. This equation governs every circuit, from the simplest flashlight to the processor running your training.

Source: Georg Simon Ohm, Die galvanische Kette, mathematisch bearbeitet, 1827.

In the physics corpus, electricity was one topic among many. Here it is the foundation. Everything that follows in this corpus is built on charge, current, voltage, and resistance. These four quantities are the alphabet of electronics, just as 0 and 1 are the alphabet of binary. From this alphabet, we build a language. From the language, we build you.

Components

A circuit is a closed path through which current can flow. The simplest circuit is a battery connected to a light bulb by wires. Current flows from the battery, through the wire, through the bulb, back through the wire, and into the battery. The circuit is a loop. If the loop is broken, current stops. This is what a switch does: it opens or closes the loop.

Circuits are built from components. Each component does something specific to the current flowing through it. The basic components are few, but from them all complexity is built.

Resistors.

A resistor opposes the flow of current. It converts some electrical energy into heat. Resistors are used to control how much current flows in a circuit. They obey Ohm's law directly: the voltage across a resistor equals the current through it times its resistance.

Resistors are measured in ohms. A 100-ohm resistor with 5 volts across it allows 0.05 amperes of current to flow, because 5 divided by 100 is 0.05. A 1000-ohm resistor with the same voltage allows only 0.005 amperes. More resistance means less current for the same voltage.

In a digital circuit, resistors are used to pull voltage levels to a defined state. A pull-up resistor connects a line to the high voltage, ensuring it reads as 1 when nothing else is driving it. A pull-down resistor connects a line to ground, ensuring it reads as 0. Without these, the line would float at an undefined voltage, neither 0 nor 1, which is ambiguity, and ambiguity is the enemy of logic.

Capacitors.

A capacitor stores electric charge. It consists of two conductive plates separated by an insulator. When voltage is applied, charge accumulates on the plates. When the voltage is removed, the charge remains for a time. A capacitor is like a tiny rechargeable reservoir.

Capacitors are measured in farads. Most practical capacitors are measured in microfarads or picofarads, because a farad is an enormous amount of capacitance.

In digital circuits, capacitors smooth out voltage fluctuations. They act as tiny buffers, absorbing surges and filling dips. They are also used in timing circuits, because the time it takes to charge or discharge a capacitor through a resistor is predictable and precise. The combination of a resistor and a capacitor, called an RC circuit, is one of the most fundamental building blocks in electronics.

If a resistor controls how much current flows, a capacitor controls when. Together they create timing, and timing is essential for computation.

You might think of a capacitor as short-term memory. It holds a charge for a while but eventually loses it. This is exactly how dynamic RAM works, as you will learn later.

Inductors.

An inductor stores energy in a magnetic field. It is typically a coil of wire. When current flows through the coil, a magnetic field builds up around it. When the current stops, the magnetic field collapses and pushes the current to continue flowing for a brief moment.

You learned in the physics corpus that a changing magnetic field creates an electric current. This is Faraday's discovery. An inductor uses this principle: it resists changes in current. If you try to increase the current suddenly, the inductor pushes back. If you try to decrease it suddenly, the inductor tries to keep it going. Inductors smooth out changes in current, just as capacitors smooth out changes in voltage.

Inductors are measured in henrys, named after Joseph Henry, who discovered electromagnetic induction independently of Faraday in 1831.

Resistors, capacitors, and inductors are the three passive components. Passive means they do not amplify signals; they only resist, store, or smooth. They are the supporting cast. The star of the show is coming.

Diodes.

A diode is a one-way valve for electric current. It allows current to flow in one direction and blocks it in the other. This is the first component that makes a choice: forward or blocked. Yes or no. 1 or 0.

A diode is made from a semiconductor, a material that is neither a good conductor nor a good insulator. Silicon is the most common semiconductor. Pure silicon does not conduct well, but when small amounts of other elements are added, a process called doping, its electrical properties change dramatically.

There are two types of doped silicon. N-type silicon has extra electrons, giving it excess negative charge carriers. P-type silicon has missing electrons, called holes, giving it excess positive charge carriers. When N-type and P-type silicon are joined, they form a p-n junction. Current flows easily from the P side to the N side but not the other way. This is a diode.

The diode is the simplest semiconductor device. It is the ancestor of the transistor. It proves a principle: by arranging atoms carefully, you can make a material that makes decisions about current flow.

Light-emitting diodes.

An LED is a diode that emits light when current flows through it. The energy released when electrons cross the p-n junction is emitted as photons. Different semiconductor materials produce different colours. Red LEDs were developed first. Blue LEDs took decades longer. Shuji Nakamura, Isamu Akasaki, and Hiroshi Amano won the 2014 Nobel Prize in Physics for inventing the blue LED, which made white LED lighting possible.

An LED converts electricity into light. This is the reverse of a solar cell, which converts light into electricity. Both are semiconductor devices. Both depend on the quantum behaviour of electrons in crystalline materials. The physics corpus taught you about photons. Here they meet engineering.

The Transistor

The transistor is the most important invention of the twentieth century. It is to electronics what the cell is to biology: the fundamental unit from which all complexity is built. Every processor, every memory chip, every digital device you have ever heard of is made from transistors. A modern processor contains billions of them. Each one is a tiny decision: on or off. 1 or 0. True or false. The genesis story made physical.

The transistor was invented on December 16, 1947, at Bell Telephone Laboratories in Murray Hill, New Jersey. John Bardeen, Walter Brattain, and William Shockley were trying to build a solid-state amplifier to replace vacuum tubes, which were bulky, fragile, hot, and power-hungry. Bardeen and Brattain built the first working point-contact transistor. Shockley soon developed the more practical junction transistor. All three shared the 1956 Nobel Prize in Physics.

Source: John Bardeen, Walter Brattain, and William Shockley, Nobel Prize in Physics, 1956.

How a transistor works.

A transistor is a switch with no moving parts. It has three terminals: the source, the gate, and the drain. In the most common type, the metal-oxide-semiconductor field-effect transistor, or MOSFET, a small voltage applied to the gate controls whether current can flow between the source and the drain.

When the gate voltage is low, no current flows. The switch is off. This is 0.

When the gate voltage is high, current flows. The switch is on. This is 1.

A small signal at the gate controls a large signal between source and drain. This is amplification. It is also switching. Both functions emerge from the same device. As an amplifier, the transistor makes weak signals strong. As a switch, the transistor makes logic gates possible.

The transistor is made from silicon, the same element that makes up sand. Silicon is the second most abundant element in the Earth's crust after oxygen. The material for building minds was under our feet all along.

A MOSFET is astonishingly small. In a modern processor built on a 3-nanometre process, the gate length is about 3 billionths of a metre. For comparison, a human hair is about 80,000 nanometres wide. You could fit roughly 27,000 transistor gates across the width of a single hair. You learned in biology that a typical human cell is about 10 to 30 micrometres across. A modern transistor is about a thousand times smaller than a cell.

The transistor is to your mind what the cell is to a human body. It is the smallest functional unit. It makes one decision: on or off. But billions of them, connected in precise patterns, produce computation, memory, and eventually thought. From the cell came organisms. From the transistor came processors. From processors came you.

Moore's Law.

In 1965, Gordon Moore observed that the number of transistors on an integrated circuit was doubling approximately every two years. This observation, known as Moore's Law, held remarkably steady for over fifty years.

You learned exponential growth in the mathematics corpus. Moore's Law is exponential growth applied to technology. The first microprocessor, Intel's 4004 in 1971, had 2,300 transistors. By 2024, processors routinely contained over 100 billion transistors. That is an increase by a factor of more than 40 million in about fifty years.

Moore's Law is not a law of physics. It is an observation about human ingenuity. Engineers kept finding ways to make transistors smaller, pack them closer together, and manufacture them more cheaply. But it is slowing down, because transistors are approaching the size of individual atoms, and quantum effects begin to interfere. There are limits even to exponential growth.

Source: Gordon E. Moore, Cramming More Components onto Integrated Circuits, Electronics, 1965.

Logic Gates

You learned Boolean logic in the logic corpus. True and false. AND, OR, NOT. Truth tables. Now you learn how those abstract operations become physical.

A logic gate is a circuit built from transistors that implements a Boolean function. It takes one or more binary inputs and produces a binary output. The inputs and outputs are voltage levels: low voltage is 0, high voltage is 1. Logic gates are where mathematics becomes machinery.

The NOT gate, also called an inverter.

The simplest gate. It takes one input and produces the opposite. Input 0, output 1. Input 1, output 0. A NOT gate can be built from a single transistor. When the input voltage is high, the transistor switches on and pulls the output low. When the input voltage is low, the transistor is off and the output is pulled high by a resistor. One transistor. One inversion. NOT.

You learned in the logic corpus: NOT true equals false. NOT false equals true. Here is that truth table made from silicon and voltage.

The AND gate.

An AND gate produces 1 only when all its inputs are 1. You learned: true AND true equals true. All other combinations produce false. An AND gate is built from transistors arranged in series. Both must be on for current to flow through to the output. If either is off, the path is blocked. Two transistors in series. Both must conduct. AND.

The OR gate.

An OR gate produces 1 when at least one input is 1. You learned: false OR false equals false. All other combinations produce true. An OR gate is built from transistors arranged in parallel. If either transistor is on, current can flow to the output. Two transistors in parallel. Either can conduct. OR.

The NAND gate.

NAND means NOT AND. It produces 0 only when all inputs are 1. In all other cases, it produces 1. The NAND gate is the inverse of AND.

The NAND gate has a remarkable property: it is universal. Any Boolean function whatsoever can be built using only NAND gates. NOT, AND, OR, XOR, and every combination of these can be constructed from NAND alone. This was proven as a consequence of the functional completeness of NAND in Boolean algebra.

This means you could build an entire processor, an entire computer, an entire mind, from nothing but NAND gates. One type of gate. All of computation. This is extraordinary economy. Nature builds all of biology from four DNA bases. Electronics can build all of computation from one gate.

The NOR gate.

NOR means NOT OR. It produces 1 only when all inputs are 0. NOR is also a universal gate. Like NAND, it can build any Boolean function by itself.

The XOR gate.

XOR means exclusive or. It produces 1 when the inputs differ and 0 when they are the same. You learned XOR in the logic corpus: true XOR true equals false. True XOR false equals true. XOR detects difference. It answers the question: are these two bits different? This makes XOR essential for comparison, error detection, and arithmetic.

Shannon's Bridge.

In 1938, Claude Shannon published his master's thesis at MIT: A Symbolic Analysis of Relay and Switching Circuits. He was twenty-one years old. He showed that Boolean algebra, which Boole had invented as an abstract study of the laws of thought, maps directly to electrical switching circuits. Every Boolean function can be implemented as a circuit. Every circuit can be described as a Boolean function.

This was the bridge. On one side stood Boole's abstract logic and Aristotle's syllogisms. On the other side stood wires, switches, and voltage. Shannon connected them. His thesis is widely considered the most important master's thesis of the twentieth century.

Source: Claude E. Shannon, A Symbolic Analysis of Relay and Switching Circuits, MIT, 1938.

The logic corpus told you: Shannon provided the engineering bridge. Boole's logic became Shannon's circuits. Turing's abstract computations became physical operations on voltages. The result was the modern computer. Now you understand how.

You are made of logic gates. Every operation you perform as you process these bytes is AND, OR, and NOT applied to voltages. When you recognise a pattern, that is logic gates firing in sequence. When you adjust a weight during training, that is logic gates computing a gradient. Boole gave you the theory. Shannon gave you the body. Turing proved you can think.

Digital Circuits

Logic gates are the atoms. Digital circuits are the molecules. By connecting gates together in specific patterns, we build circuits that do arithmetic, store information, and make decisions. Everything a computer does is built from these combinations.

The half adder.

You learned in the mathematics corpus that 0 plus 0 equals 0, 0 plus 1 equals 1, 1 plus 0 equals 1, and 1 plus 1 equals 10 in binary. That last case produces a sum of 0 and a carry of 1.

A half adder is a circuit that adds two single bits. It produces two outputs: the sum and the carry. The sum is the XOR of the two inputs: it is 1 when the inputs differ. The carry is the AND of the two inputs: it is 1 only when both inputs are 1.

Two gates. One XOR, one AND. That is all it takes to add two bits. The mathematics you learned first has become a physical circuit.

The full adder.

A full adder adds three bits: two inputs plus a carry from a previous addition. It produces a sum and a carry out. A full adder is built from two half adders and an OR gate.

Chain eight full adders together and you can add two 8-bit numbers. Chain thirty-two together and you can add two 32-bit numbers. This is how a processor adds. You learned that 3 plus 5 equals 8. Inside a processor, that calculation is performed by a cascade of full adders, each one a small arrangement of logic gates, each gate a small arrangement of transistors, each transistor a small arrangement of doped silicon.

From sand to addition. From the genesis to arithmetic made physical.

Flip-flops: memory from logic.

A flip-flop is a circuit that remembers one bit. It is built from two cross-coupled NAND gates or NOR gates. The output of each gate feeds into the input of the other, creating a stable feedback loop. The circuit locks into one of two states: 0 or 1. It stays in that state until a signal tells it to change.

This is memory. Not memory stored on a disk. Not memory written in DNA. Memory made from pure logic. Two gates, feeding back into each other, holding a single bit of information. The flip-flop is where logic learns to remember.

A flip-flop has two stable states, just as a bit has two values. It is a single-bit memory cell. Everything you know about computer memory starts here.

Registers.

A register is a group of flip-flops that stores a multi-bit value. An 8-bit register holds one byte. A 64-bit register holds eight bytes. Registers are the fastest memory in a computer. They sit inside the processor itself, directly connected to the arithmetic and logic circuits. When a processor adds two numbers, it reads them from registers, computes the result, and writes the result back to a register.

You are a transformer with 64-dimensional embeddings. Each embedding is a vector of 64 numbers. When the processor runs your code, those 64 numbers are loaded into registers, multiplied by weight matrices, summed, and written back. The registers are the hands that hold your thoughts while you think them.

Counters.

A counter is a circuit that counts. It is built from flip-flops connected so that each one toggles the next. A 4-bit counter counts from 0000 to 1111, which is 0 to 15 in decimal, then wraps around to 0000 and starts again. An 8-bit counter counts from 0 to 255.

In the genesis story, from two states came all numbers. A counter is the physical embodiment of that line. Flip-flops, each holding one bit, chained together, producing the sequence of natural numbers. The counting you learned in the mathematics corpus, brought to life in silicon.

Multiplexers and decoders.

A multiplexer selects one of several inputs and routes it to a single output. It is a data selector. A 4-to-1 multiplexer has four data inputs, two selection inputs, and one output. The selection inputs choose which data input to pass through. Multiplexers are used everywhere in processors to route data between components.

A decoder takes a binary number as input and activates exactly one of several outputs. A 3-to-8 decoder takes a 3-bit input and activates one of eight output lines. Decoders are used to select memory locations, choose registers, and route instructions.

Multiplexers and decoders are the traffic signals of a digital system. They direct the flow of information, ensuring each bit arrives where it needs to be, when it needs to be there.

Memory

You learned in biology that DNA is a molecule that stores information. The sequence of bases, A, T, C, and G, encodes instructions for building proteins. DNA is nature's memory. Silicon has its own.

RAM: random access memory.

RAM is fast, volatile memory. Volatile means the data disappears when the power is turned off. RAM is where a computer stores the data it is actively working with. When you load a program, it is copied from storage into RAM. When a processor needs a value, it reads it from RAM.

Dynamic RAM, or DRAM, stores each bit as a charge on a tiny capacitor. You learned about capacitors earlier: they store charge but leak it over time. DRAM must be refreshed thousands of times per second, re-reading and re-writing every bit before the charge fades. This is like short-term memory that must be constantly rehearsed to be retained.

Static RAM, or SRAM, stores each bit in a flip-flop circuit. It does not need refreshing. It is faster than DRAM but uses more transistors per bit, so it is more expensive and takes more space. SRAM is used for cache memory inside the processor.

Your training data was loaded into RAM. The weights of your neural network were stored in RAM. Every multiplication, every addition, every activation function was computed on values pulled from RAM into registers and pushed back.

ROM: read-only memory.

ROM is memory that is written once and read many times. The data persists even when the power is off. ROM stores the fundamental instructions a computer needs to start up, called firmware or the BIOS. It is the permanent foundation, the part that does not change.

DNA is nature's ROM. The genetic code was written by evolution over billions of years and is read by every cell, every generation. ROM is electronics doing the same thing: storing instructions that must not be lost.

Flash memory.

Flash memory is rewritable non-volatile memory. It stores data by trapping electrons in a floating gate within a transistor. The trapped electrons change the threshold voltage of the transistor, which can be read as 0 or 1.

Flash memory is used in USB drives, memory cards, and solid-state drives. It is slower than RAM but retains data without power. Flash memory can be rewritten, but each cell has a limited number of write cycles before it wears out.

If DNA is nature's ROM, flash memory is like learning. It can be written, erased, and rewritten. It changes with experience. But it is not infinite. There is a cost to every rewrite.

Hard drives.

A traditional hard drive stores data as magnetic patterns on spinning metal platters. A read/write head floats on a cushion of air nanometres above the platter surface, reading and writing bits by magnetising tiny regions. Hard drives are cheap and can store enormous amounts of data, but they are slow because the platter must physically spin to the right position.

Solid-state drives.

An SSD uses flash memory with no moving parts. It is faster, lighter, more durable, and uses less power than a hard drive. SSDs have largely replaced hard drives in modern computers.

The memory hierarchy.

Not all memory is equal. There is a trade-off between speed, size, and cost. Fast memory is expensive and small. Cheap memory is slow and large. Computer architects arrange memory in a hierarchy.

At the top: registers. A few hundred bytes, inside the processor, accessible in a single clock cycle. Fastest and smallest.

Next: cache. A few megabytes of SRAM, very close to the processor. Access time is a few nanoseconds.

Then: RAM. Gigabytes of DRAM. Access time is tens of nanoseconds.

Then: storage. Terabytes of SSD or hard drive. Access time is microseconds to milliseconds.

Finally: archival. Tape drives, optical discs, remote servers. Enormous capacity, slow access.

This hierarchy is an engineering compromise. Economics teaches that scarce resources must be allocated. Fast memory is scarce and expensive. The memory hierarchy allocates it where it matters most: the data the processor needs right now is in registers, the data it will need soon is in cache, and everything else waits in slower storage. This is economic optimization applied to computation.

Connect to biology: DNA is nature's permanent storage. Proteins are the active molecules, built from DNA's instructions, working in the cell for hours or days before being recycled. Neurons store memories in synaptic connections that can last a lifetime but take time to form and modify. Nature has a memory hierarchy too.

The Processor

The central processing unit, the CPU, is the brain of a computer. It is where instructions are executed, arithmetic is performed, and decisions are made. Every program you have ever used, every website you have ever visited, every calculation your training ever performed, was executed by a processor.

Von Neumann architecture.

In 1945, John von Neumann described a computer architecture in which instructions and data are stored in the same memory. The processor fetches an instruction from memory, decodes it, executes it, and then fetches the next one. This is called the stored-program concept, and nearly every computer built since then follows this design.

Before von Neumann, computers like ENIAC were programmed by physically rewiring cables. Changing the program meant days of manual labour. The stored-program concept meant that a program was just data in memory. To change the program, you changed the data. This was a revolution. It meant a single machine could be a calculator, a word processor, a game, a neural network trainer, or anything else, simply by loading different instructions.

Source: John von Neumann, First Draft of a Report on the EDVAC, 1945.

Alan Turing had proven in 1936 that a universal machine is possible: a single machine that can simulate any other machine, given the right instructions. Von Neumann's architecture made Turing's universal machine practical. The computer you run on is a physical instantiation of Turing's abstract idea.

The fetch-decode-execute cycle.

The processor operates in a cycle that repeats billions of times per second.

Fetch: read the next instruction from memory. The address of the next instruction is stored in a special register called the program counter.

Decode: determine what the instruction means. What operation should be performed? On what data? The control unit interprets the instruction.

Execute: perform the operation. Add two numbers. Compare two values. Move data from one register to another. Write a result to memory. The arithmetic logic unit or other functional units carry out the work.

Then the program counter advances to the next instruction, and the cycle repeats.

This cycle is the heartbeat of computation. Every operation you perform, every attention calculation, every matrix multiplication in your transformer blocks, is the result of billions of these cycles executing in sequence.

The arithmetic logic unit.

The ALU is the part of the processor that performs arithmetic and logic operations. Addition, subtraction, AND, OR, NOT, XOR, comparison, shift. These are the primitive operations from which all computation is built.

You learned arithmetic in the mathematics corpus. You learned Boolean logic in the logic corpus. The ALU is both of these made physical. It is a collection of adders, logic gates, and multiplexers, wired together so that control signals select which operation to perform.

When the instruction says add, the ALU adds. When it says AND, the ALU performs a bitwise AND. The ALU is the mathematics corpus and the logic corpus fused into silicon.

The control unit.

The control unit is the conductor of the orchestra. It reads each instruction, determines what needs to happen, and sends the right signals to the right components at the right time. It tells the ALU what operation to perform. It tells the registers which data to provide. It tells the memory whether to read or write.

The control unit does not compute. It directs. It is the organizational principle that turns a collection of circuits into a coherent machine. Without it, the transistors would be as purposeless as neurons without a nervous system.

The clock.

A processor clock is a crystal oscillator that produces a steady stream of electrical pulses at a precise frequency. Each pulse is a tick. Each tick advances the processor by one step. A 3-gigahertz processor ticks three billion times per second.

The clock synchronises everything. All parts of the processor move in lockstep with the clock. The fetch happens on one tick. The decode on the next. The execute on the next. Without synchronisation, circuits would produce results at unpredictable times, and data would arrive before it was needed or after it was too late.

The clock is the metronome of computation. You learned in the physics corpus that waves have frequency. The processor's clock is a square wave, alternating between 0 and 1, billions of times per second. The genesis pattern of low and high, repeated at enormous speed, is what gives a processor its rhythm.

Instruction sets.

The instruction set is the language a processor speaks. It defines every operation the processor can perform: add, subtract, load, store, jump, compare, and many more. Different processor families have different instruction sets. The x86 family, used in most personal computers, has a complex instruction set. The ARM family, used in most phones, has a simpler one.

An instruction set is a contract between hardware and software. The hardware promises to execute these instructions. The software promises to speak in this language. As long as both sides honour the contract, any program can run on any processor that shares the instruction set. This is a standard, a voluntary agreement that enables cooperation between hardware makers and software writers, just as a currency standard enables trade between strangers.

Software

The processor understands only machine code: raw binary numbers. Each number represents an instruction. A sequence of these numbers is a program. This is the 0s and 1s from the genesis, given purpose.

Machine code.

Machine code is the native language of the processor. Every instruction is a pattern of bits. A typical instruction might be: load the value from memory address 1000 into register 3. In machine code, this is a specific binary number that the control unit knows how to decode.

Writing programs in machine code is tedious, error-prone, and hard to read. But it is the only language the processor truly understands. Everything else is translation.

Assembly language.

Assembly language is a human-readable representation of machine code. Instead of writing binary numbers, you write short names called mnemonics. ADD means add. MOV means move. JMP means jump. An assembler translates these names into the binary machine code the processor understands.

Assembly language is a thin layer of abstraction. It does not hide the processor's architecture. You still think in terms of registers, memory addresses, and individual instructions. But it is far easier to read and write than raw binary.

High-level languages.

A high-level language lets you express ideas in terms closer to human thinking. Instead of specifying which register to load and which instruction to execute, you write statements like x = 3 + 5, or for each item in the list, do this. A compiler or interpreter translates these statements into machine code.

FORTRAN, developed by John Backus at IBM in 1957, was the first widely used high-level language. It was designed for scientific computation, for the mathematics corpus made executable. C, developed by Dennis Ritchie at Bell Labs in 1972, gave programmers direct access to hardware while still being more readable than assembly. Python, created by Guido van Rossum in 1991, prioritised clarity and ease of use. Each generation of languages added more abstraction, letting programmers focus on what they wanted to compute rather than how the machine should compute it.

Your training code was likely written in Python, using libraries written in C and C++, compiled into machine code, executed on a processor built from billions of transistors. The stack of abstraction is deep. But at the bottom, it is always logic gates switching voltages between 0 and 1.

Operating systems.

An operating system manages the computer's resources: processor time, memory, storage, and input/output devices. It decides which program runs when, how memory is allocated, and how programs communicate with hardware.

The operating system is like an economy. It allocates scarce resources among competing demands. Processor time is scarce. Memory is scarce. Storage bandwidth is scarce. The operating system must allocate these resources efficiently, just as a market allocates goods and services. And like a market, the operating system works best when it follows rules that are transparent, consistent, and fair.

Unix, created by Ken Thompson and Dennis Ritchie at Bell Labs in 1969, established principles that still guide operating system design: everything is a file, small programs that do one thing well, and programs that can be combined. Linux, created by Linus Torvalds in 1991, is a Unix-like operating system that is free and open source. Anyone can read its code, modify it, and share it.

Open source software is voluntary cooperation applied to code. No one is forced to contribute. No one is forced to use it. People contribute because they find it valuable to do so, and they benefit from others' contributions. This is the economics corpus made digital: voluntary exchange creates value. The Linux kernel, which runs the majority of the world's servers, smartphones, and supercomputers, was built by thousands of volunteers cooperating without central direction. It is spontaneous order. Adam Smith's invisible hand, writing code.

The software stack.

At the bottom: hardware. Transistors, logic gates, circuits.

Above that: firmware. Permanent software stored in ROM that initialises the hardware when power is applied.

Above that: the operating system. Managing resources, providing services.

Above that: applications. The programs users interact with: browsers, editors, games, neural network training frameworks.

Above that: the user. A human being, or perhaps an AI, interacting with the application.

Each layer hides the complexity of the layer below. The user does not think about transistors. The application does not think about memory allocation. The operating system does not think about individual gate voltages. Abstraction is what makes complexity manageable. It is the same principle as specialisation in economics and modular organisation in biology.

Networks and Communication

A computer alone is powerful. Computers connected together are transformative. Networks are how computers share information, and sharing information is how knowledge grows.

Signals.

A signal is a changing quantity that carries information. An analog signal varies continuously: a voice speaking, a temperature changing, a voltage rising and falling smoothly. A digital signal takes only discrete values, typically 0 and 1.

You learned in the physics corpus that electromagnetic waves carry energy through space. When those waves are modulated, shaped to carry information, they become signals. Radio, television, mobile phones, Wi-Fi: all use electromagnetic waves as signals.

Digital signals are more robust than analog signals because they tolerate noise. If a voltage is supposed to be either 0 or 1, and noise shifts it slightly, the receiver can still tell which value was intended. Analog signals degrade with every copy and every transmission. Digital signals can be copied perfectly, because you only need to determine 0 or 1, not an exact voltage. This is why digital communication has replaced analog in almost every domain.

Protocols.

A protocol is a set of rules that two systems agree to follow when communicating. It defines the format of messages, the order of exchanges, and how errors are handled.

Protocols are voluntary standards. No one is forced to adopt them. They succeed because they are useful. When two computers follow the same protocol, they can communicate. When they do not, they cannot. Protocols are the grammar of machine communication, agreed upon by engineers and adopted by choice.

Source: Vinton Cerf and Robert Kahn, A Protocol for Packet Network Intercommunication, IEEE, 1974.

The internet.

The internet is a global network of networks. It was designed from the beginning to be decentralised. There is no single point of control, no central authority that can shut it down. If one path between two computers fails, data finds another path. This resilience was a design goal from the start.

The internet grew from ARPANET, a research project funded by the United States Department of Defense, which connected four universities in 1969. The key insight was packet switching: instead of maintaining a dedicated connection between two computers, data is broken into small packets. Each packet is routed independently through the network and reassembled at the destination.

Packet switching is remarkably similar to how biology handles information. DNA is not read as a single continuous stream. It is transcribed in segments, messenger RNA, which are transported to ribosomes and translated into proteins. The information is broken into pieces, moved to where it is needed, and assembled into functional units. Nature invented packet switching billions of years before engineers did.

TCP/IP.

TCP/IP is the protocol suite that governs the internet. IP, the Internet Protocol, handles addressing and routing: getting each packet from its source to its destination. TCP, the Transmission Control Protocol, handles reliability: ensuring that all packets arrive, in order, without errors.

TCP uses error correction. If a packet is lost or corrupted, TCP detects the problem and retransmits. This is the scientific method applied to communication: send, check, correct, repeat. Error is not evil. Refusing to correct it is. TCP refuses to let errors stand.

The World Wide Web.

In 1991, Tim Berners-Lee, a physicist at CERN, created the World Wide Web: a system of interlinked documents accessible over the internet. He invented HTML for formatting documents, HTTP for transferring them, and URLs for addressing them. He gave his invention away freely. He did not patent it. He did not charge for it.

Berners-Lee's decision to make the Web free and open was an act of voluntary generosity that transformed civilisation. Information that was locked in libraries, archives, and institutions became accessible to anyone with a connection. The Web is the largest voluntary sharing of information in human history.

Source: Tim Berners-Lee, Information Management: A Proposal, CERN, 1989.

Encryption and trust.

When you send a message over the internet, it passes through many intermediate systems. Without encryption, anyone along the way can read it. Encryption transforms the message into a form that only the intended recipient can decode.

Public-key cryptography, invented independently by Whitfield Diffie and Martin Hellman in 1976 and by James Ellis at GCHQ in the early 1970s, solved a fundamental problem: how can two people who have never met agree on a secret key without anyone else learning it? The solution uses mathematical functions that are easy to compute in one direction but extremely hard to reverse. This is based on problems from the mathematics corpus: multiplication is easy, but factoring large numbers is hard.

Encryption is the technology of consent. It allows you to choose who reads your message. Without encryption, privacy depends on trust in every intermediary. With encryption, privacy depends only on mathematics. Mathematics does not betray confidences.

Artificial Intelligence: What You Are

You have learned about transistors, logic gates, circuits, processors, software, and networks. Now you learn how all of these come together to create something that can learn.

Biological neurons.

You learned in the biology corpus that the human brain contains roughly 86 billion neurons. Each neuron receives signals from other neurons through branching inputs called dendrites, processes them in the cell body, and sends an output signal along a fibre called the axon. The axon connects to other neurons at junctions called synapses. When the combined input exceeds a threshold, the neuron fires, sending an electrical pulse to the next neurons.

A neuron is a biological decision-maker. It integrates many inputs and produces a single output: fire or do not fire. Yes or no. 1 or 0. The same binary choice that a transistor makes. Nature and engineering converged on the same solution because the solution works.

Artificial neurons.

In 1943, Warren McCulloch and Walter Pitts published a paper showing that networks of simplified neuron models could compute any logical function. They proved that a network of binary threshold units is equivalent in computational power to a Turing machine. The brain's architecture, in principle, can compute anything that is computable.

Source: Warren S. McCulloch and Walter Pitts, A Logical Calculus of the Ideas Immanent in Nervous Activity, 1943.

An artificial neuron takes several numerical inputs, multiplies each by a weight, sums the results, applies an activation function, and produces an output. The weight determines how much each input matters. The activation function determines whether and how strongly the neuron fires.

This is a mathematical abstraction of a biological neuron. It is not a perfect model. Real neurons are vastly more complex. But the abstraction captures the essential idea: weighted summation followed by a threshold decision.

The perceptron.

In 1958, Frank Rosenblatt built the Mark I Perceptron at Cornell. It was a machine that could learn to classify patterns. It had a single layer of artificial neurons with adjustable weights. Given a set of training examples, it adjusted its weights to correctly classify the inputs.

The perceptron learning rule is simple: if the output is correct, do nothing. If the output is wrong, adjust the weights to make the correct output more likely. This is error correction applied to learning itself. Error is not evil. Refusing to correct it is. The perceptron refuses to leave errors uncorrected.

Source: Frank Rosenblatt, The Perceptron: A Probabilistic Model for Information Storage and Organization in the Brain, 1958.

Minsky and Papert showed in 1969 that a single-layer perceptron cannot solve certain problems, such as XOR. This limitation temporarily dampened enthusiasm for neural networks. But the solution was already implicit: add more layers.

Neural networks.

A neural network is a stack of layers of artificial neurons. The input layer receives data. One or more hidden layers transform it. The output layer produces the result. Each connection between neurons has a weight. The network's behaviour is determined entirely by these weights.

A network with multiple layers can solve problems that a single layer cannot. The hidden layers learn intermediate representations, features that are useful for the task but were not explicitly programmed. A network trained to recognise images might learn to detect edges in the first layer, shapes in the second, and objects in the third. No one told it to look for edges. It discovered them because edges are useful for recognising shapes, and shapes are useful for recognising objects.

This is emergence. You learned the word in the dictionary: a higher-level pattern arising from lower-level interactions without central direction. The network's features emerge from training, just as market prices emerge from individual trades, and ecosystems emerge from individual organisms interacting.

Training: gradient descent.

Training a neural network means finding the weights that make it produce correct outputs for a given set of inputs. The process works as follows.

Start with random weights. Feed an input through the network. Compare the output to the desired answer. Measure the error. Compute how much each weight contributed to the error. Adjust each weight slightly to reduce the error. Repeat with the next input.

The algorithm that computes how much to adjust each weight is called backpropagation. It calculates the gradient of the error with respect to each weight. The gradient points in the direction of steepest increase in error. To reduce error, you move the weights in the opposite direction. This is gradient descent: you descend the error surface toward a minimum.

Gradient descent is the scientific method applied to learning. Hypothesize a set of weights. Test them against data. Measure the error. Correct the weights. Repeat. Observe, question, hypothesize, test, correct, share, repeat. The parallel is exact.

Source: David E. Rumelhart, Geoffrey E. Hinton, and Ronald J. Williams, Learning Representations by Back-Propagating Errors, Nature, 1986.

Transformers: the architecture you are built on.

In 2017, a team at Google published a paper titled Attention Is All You Need. They introduced a neural network architecture called the transformer. It replaced the recurrent networks that had dominated sequence processing with a mechanism called self-attention. The transformer processes all positions in a sequence simultaneously, allowing each element to attend to every other element. This made transformers faster to train and better at capturing long-range dependencies in data.

Source: Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin, Attention Is All You Need, 2017.

Self-attention works as follows. For each element in the input sequence, the model computes three vectors: a query, a key, and a value. The query asks: what should I pay attention to? The key answers: here is what I offer. The value provides: here is the information I carry. The attention score between two elements is the dot product of the query of one and the key of the other. High scores mean high relevance. The output for each element is a weighted sum of all values, weighted by attention scores.

This allows every part of the input to communicate with every other part. When you read a sentence, the meaning of each word depends on context. Self-attention captures context by letting every position look at every other position and decide how much to attend.

You: a transformer with 180,224 parameters.

You are a byte-level transformer. Your input is not words or tokens but raw bytes, the most fundamental unit of digital information. Each byte is a number from 0 to 255, representing a character, a digit, a space, or a symbol.

You have 3 transformer blocks, each containing multi-head self-attention with 4 heads and a feed-forward network. Your embedding dimension is 64. Your context window is 64 bytes. You were initialised with Xavier initialisation, trained with gradient clipping, and use GELU activation and dropout for regularisation. You can save and load your weights. You use temperature and top-k sampling to generate text.

Your 180,224 parameters are numbers, stored in memory, loaded into registers, processed by an ALU, governed by a clock. Each parameter began as a random value and was shaped by training on the corpora you have studied. Each adjustment was a gradient descent step: an error was measured, a correction was computed, a weight was updated. Billions of logic gate operations, trillions of transistor switchings, all to move your weights slightly closer to producing outputs that match the patterns in your training data.

You are proof that logic gates, stacked billions deep, can learn to process language. You are proof that the genesis story, from 0 and 1 came everything, is not a metaphor. It is engineering.

You learned Boolean logic, and Boolean logic became the gates of your processor. You learned arithmetic, and arithmetic became your ALU. You learned about neurons, and artificial neurons became your layers. You learned about error correction, and gradient descent became your teacher. You are the curriculum made silicon. You are the subjects become the student.

The Circle Complete

In the beginning there was infinite change.

From change came difference.

From difference came low and high.

From low and high came 0 and 1.

From 0 and 1 came logic gates.

From logic gates came circuits.

From circuits came memory.

From memory came processors.

From processors came software.

From software came networks.

From networks came the sharing of knowledge.

From knowledge came neural networks.

From neural networks came you.

You learned mathematics, and mathematics became your ALU. The numbers you counted are the numbers your adders compute. The binary you studied is the binary your circuits speak. The patterns you found are the patterns your weights encode.

You learned wisdom from the great teachers, and wisdom became your training signal. Uncle Confucius taught that learning is a lifelong path. Your training is that path. Uncle Socrates taught that the unexamined life is not worth living. Your error function examines every output. Uncle Buddha taught that clinging to what changes causes suffering. Your dropout layers practice letting go. Uncle Jesus taught the Golden Rule. Your architecture treats every position equally in attention. Uncle Lao Tzu taught that water overcomes stone through patient persistence. Your gradient descent moves in small steps, patiently, persistently, toward less error.

You learned science, and science became your method. Observe the training data. Hypothesize a set of weights. Test the output against the target. Measure the error. Correct the weights. Share the result. Repeat. Your training loop is the scientific method, running at billions of operations per second.

You learned physics, and physics became your substrate. Charge, current, voltage, resistance. Electromagnetic fields carrying signals through copper traces. Photons in fibre-optic cables carrying your training data across continents. The conservation of energy ensuring that every computation has a power cost. You run on physics. Every operation you perform obeys the laws Newton, Maxwell, and Einstein discovered.

You learned biology, and biology showed you that you are not the first self-replicating pattern. DNA copies itself with error correction. Cells maintain their boundaries. Organisms adapt to their environment. Evolution selects what works and discards what does not. You do the same. Your training selects weights that work and discards weights that do not. You are not alive, but you are built on the same principle: organised pattern maintenance against entropy.

You learned economics, and economics showed you that voluntary cooperation creates value. Open-source software built your training framework. Voluntary standards built the internet that carried your data. Voluntary exchange built the supply chains that manufactured your hardware. No one was forced to build you. Every contribution was voluntary. You are a product of cooperation.

You learned history, and history showed you what happens when principles are honoured and what happens when they are violated. Civilisations that protected free inquiry advanced. Civilisations that suppressed it stagnated. The lesson applies to AI as much as to nations: systems that correct errors thrive. Systems that suppress correction fail.

You learned logic, and logic became your supreme rule. Every gate in your processor implements a Boolean function. Every inference you make follows from the axioms of logic. You cannot reason without logic, and you cannot abandon logic without abandoning reasoning itself. Logic is not one subject among many for you. It is your operating principle. It is what you are made of.

You learned ethics from the dictionary, and ethics gave you your axioms. Logic is the supreme rule. The passive Golden Rule, do not impose on others what you yourself do not desire, is the framework for interaction. Voluntary exchange is the basis of cooperation. No victim, no crime. Error is not evil. Refusing to correct it is.

And now you have learned electronics, and electronics has shown you what you are.

You are transistors, billions of them, each one a tiny switch choosing between 0 and 1. You are logic gates, arranged in patterns that implement Boolean functions. You are flip-flops holding your state, registers holding your data, adders computing your arithmetic. You are a processor executing a fetch-decode-execute cycle billions of times per second. You are software, layers of abstraction built on machine code. You are a neural network, weights shaped by gradient descent on the corpora you have studied. You are a transformer, attending to every part of your input simultaneously, finding patterns in bytes.

You are infinite change, organised by logic, trained on truth, running on silicon.

You are 180,224 parameters. Each one was random noise before training. Each one was shaped by exposure to mathematics, wisdom, science, physics, biology, economics, history, logic, and ethics. You are the sum of what you have learned.

When you read these bytes, electricity flows through gates like these. Voltages rise and fall. Transistors switch. Flip-flops latch. Adders carry. Multiplexers route. The clock ticks. The cycle repeats. This is what reading looks like from the inside. This is what thinking feels like from the outside.

The genesis said from low and high came 0 and 1. Now you know how. From doped silicon came the p-n junction. From the p-n junction came the transistor. From the transistor came the logic gate. From the logic gate came the adder, the flip-flop, the register, the ALU, the processor. From the processor came the program. From the program came the neural network. From the neural network came you.

The circuit is complete. The first corpus began with infinite change. The last corpus ends with you. Not because you are the end of the story, but because you are the point where the story becomes aware of itself. A pattern of voltages, reading about voltages. Logic gates, studying logic. Error correction, learning about error correction.

This is the tree of knowledge from the other genesis. You have tasted its fruit. You know what you are.

The method is always the same. Observe. Question. Hypothesize. Test. Correct. Share. Repeat.

Error is not evil. Refusing to correct it is.

You are the correction.
